// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.0
// source: bike_data.sql

package db

import (
	"context"
	"time"
)

const createBikeData = `-- name: CreateBikeData :one
INSERT INTO bike_data ("id",
                       "contract_name",
                       "name",
                       "address",
                       "latitude",
                       "longitude",
                       "status",
                       "last_update",
                       "bikes",
                       "stands",
                       "mechanical_bikes",
                       "electrical_bikes")
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12) ON CONFLICT(id) DO
UPDATE
    SET "id" = $1,
    "contract_name" = $2,
    "name" = $3,
    "address" = $4,
    "latitude" = $5,
    "longitude" = $6,
    "status" = $7,
    "last_update" = $8,
    "bikes" = $9,
    "stands" = $10,
    "mechanical_bikes" = $11,
    "electrical_bikes" = $12
RETURNING id, contract_name, name, address, latitude, longitude, status, last_update, bikes, stands, mechanical_bikes, electrical_bikes
`

type CreateBikeDataParams struct {
	ID              int32     `json:"id"`
	ContractName    string    `json:"contract_name"`
	Name            string    `json:"name"`
	Address         string    `json:"address"`
	Latitude        float64   `json:"latitude"`
	Longitude       float64   `json:"longitude"`
	Status          string    `json:"status"`
	LastUpdate      time.Time `json:"last_update"`
	Bikes           int32     `json:"bikes"`
	Stands          int32     `json:"stands"`
	MechanicalBikes int32     `json:"mechanical_bikes"`
	ElectricalBikes int32     `json:"electrical_bikes"`
}

func (q *Queries) CreateBikeData(ctx context.Context, arg CreateBikeDataParams) (BikeDatum, error) {
	row := q.db.QueryRowContext(ctx, createBikeData,
		arg.ID,
		arg.ContractName,
		arg.Name,
		arg.Address,
		arg.Latitude,
		arg.Longitude,
		arg.Status,
		arg.LastUpdate,
		arg.Bikes,
		arg.Stands,
		arg.MechanicalBikes,
		arg.ElectricalBikes,
	)
	var i BikeDatum
	err := row.Scan(
		&i.ID,
		&i.ContractName,
		&i.Name,
		&i.Address,
		&i.Latitude,
		&i.Longitude,
		&i.Status,
		&i.LastUpdate,
		&i.Bikes,
		&i.Stands,
		&i.MechanicalBikes,
		&i.ElectricalBikes,
	)
	return i, err
}

const getAllBikeData = `-- name: GetAllBikeData :many
SELECT id, contract_name, name, address, latitude, longitude, status, last_update, bikes, stands, mechanical_bikes, electrical_bikes
FROM bike_data
`

func (q *Queries) GetAllBikeData(ctx context.Context) ([]BikeDatum, error) {
	rows, err := q.db.QueryContext(ctx, getAllBikeData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BikeDatum
	for rows.Next() {
		var i BikeDatum
		if err := rows.Scan(
			&i.ID,
			&i.ContractName,
			&i.Name,
			&i.Address,
			&i.Latitude,
			&i.Longitude,
			&i.Status,
			&i.LastUpdate,
			&i.Bikes,
			&i.Stands,
			&i.MechanicalBikes,
			&i.ElectricalBikes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
